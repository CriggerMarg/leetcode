namespace leetcode.LinkedList;

public class _92
{

    public ListNode ReverseBetween(ListNode head, int left, int right)
    {
        var dummy = new ListNode(0, head); // эта херабора нужна потому что лист может состоять из двух нод, например [3,5] и ответ должен
                                           // быть [5,3], но если мы будем возвращать head то вернём [3,null] 
                                           // поэтому надо сделать фейковую голову с next, который мы сможем вращать

        // теперь сделаем себе ноду "предыдущая", чтобы дойти до ноды предыдущей той, которую надо вращать 
        // это нужно для того чтобы не потерять ссылку на неё в будущем
        ListNode prev = dummy; // тут главное не поставить сразу ссылку на ноду с head, потому что возможно нам сразу надо будет её вращать

        // дальше надо дойти до ноды с которой надо стартовать вращение
        // это делается тупо по количеству, значение ноды неважно
        for (int i = 0; i < left - 1; i++) prev = prev.next;

        // теперь надо делать магию: в цикле
        // будем каждый раз менять ссылки элементов друг на друга
        // например, было 0->1->2->3->4->5 и стартовать надо с 2
        // значит prev будет на 1. Создадим ноду curr чтобы иметь текущую
        ListNode curr = prev.next;

        // теперь у нас есть ссылки на 1 и на 2.
        // дальше надо делать так: у нас есть ссылка на 3 (из 2). Поставим ей в next следующую ноду, 4.
        // Получим 0->1->2->4->5 и где-то есть 3 который ведёт на 4 
        // Потом поставим тройке ссылку на 2
        // и поставим prev.next ссылку на 3. 
        // получим 0->1->3->2->4->5
        // перейдём на следующее звено - 4, и повторим 

        // крутить надо столько раз сколько составляет
        // разница в left и right, то есть например для left = 2 и right = 4, разница будет 2, то есть 2 итерации
        // это логично: после первой мы получим 0->1->3->2->4->5, после второй 0->1->4->3->2->5 что и есть желаемый результат
        for (int i = 0; i < right - left; i++)
        {
            var fwd = curr.next; // на первой итерации здесь будет 3. На второй - 4
            curr.next = fwd.next; // присвоим 2.next = 4. На второй круг 2.next = 5. важный момент: curr не меняется, это всегда 
                                  // звено которое изначально шло первым за prev. Оно по сути в этом алгоритме тонет, поэтому ему надо 
                                  // ставить next максимально возможный на текущем этапе
            fwd.next = prev.next; // тут присвоим 3.next = 2. На втором круге 4.next = 3 

            // важный момент, тут я наебался: нельзя ставить fwd.next = curr, нам не надо всегда ставить ссылку на 2
            // нам надо ставить ссылку на то, что стоит следующим за prev, а после первой итерации там будет 3
            // на второй итерации нам надо поставить 4.next = 3

            prev.next = fwd;  // и тут мы ставим в 1.next = 3
                              // получая 0->1->3->2->4->5
        }

        // как я писал выше, возвращаем не голову, а именно это звено потому что голову могли поменять
        return dummy.next;
    }
}
